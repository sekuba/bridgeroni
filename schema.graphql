type SpokePool_FilledRelay {
  id: ID!
  inputToken: String!
  outputToken: String!
  inputAmount: BigInt!
  outputAmount: BigInt!
  repaymentChainId: BigInt!
  originChainId: BigInt!
  depositId: BigInt!
  fillDeadline: BigInt!
  exclusivityDeadline: BigInt!
  exclusiveRelayer: String!
  relayer: String!
  depositor: String!
  recipient: String!
  messageHash: String!
  relayExecutionInfo_0: String!
  relayExecutionInfo_1: String!
  relayExecutionInfo_2: BigInt!
  relayExecutionInfo_3: BigInt!
  # Metadata fields
  chainId: BigInt!
  txHash: String!
  from: String
  to: String
}

type SpokePool_FilledV3Relay {
  id: ID!
  inputToken: String!
  outputToken: String!
  inputAmount: BigInt!
  outputAmount: BigInt!
  repaymentChainId: BigInt!
  originChainId: BigInt!
  depositId: BigInt!
  fillDeadline: BigInt!
  exclusivityDeadline: BigInt!
  exclusiveRelayer: String!
  relayer: String!
  depositor: String!
  recipient: String!
  message: String!
  relayExecutionInfo_0: String!
  relayExecutionInfo_1: String!
  relayExecutionInfo_2: BigInt!
  relayExecutionInfo_3: BigInt!
  # Metadata fields
  chainId: BigInt!
  txHash: String!
  from: String
  to: String
}

type SpokePool_FundsDeposited {
  id: ID!
  inputToken: String!
  outputToken: String!
  inputAmount: BigInt!
  outputAmount: BigInt!
  destinationChainId: BigInt!
  depositId: BigInt!
  quoteTimestamp: BigInt!
  fillDeadline: BigInt!
  exclusivityDeadline: BigInt!
  depositor: String!
  recipient: String!
  exclusiveRelayer: String!
  message: String!
  # Metadata fields
  chainId: BigInt!
  txHash: String!
  from: String
  to: String
}

type CrosschainMessage {
  id: ID! # Format: "acrossV3:{originChainId}-{depositId}"
  protocol: String! # "acrossV3"
  idMatching: String! # "{originChainId}-{depositId}"
  
  # Outbound message data
  blockOutbound: BigInt
  timestampOutbound: BigInt
  txHashOutbound: String
  chainIdOutbound: BigInt
  fromOutbound: String # depositor address
  
  # Inbound message data  
  blockInbound: BigInt
  timestampInbound: BigInt
  txHashInbound: String
  chainIdInbound: BigInt
  toInbound: String # recipient address
  
  # Status tracking
  matched: Boolean! # true when both outbound and inbound are recorded
  latency: BigInt # timestamp difference (inbound - outbound) in seconds, only set when matched
}

type AppPayload {
  id: ID! # Format: "{transportingMsgProtocol}:{transportingMessageId}:{idMatching}"
  appName: String! # "AcrossV3"
  
  # Associated message info
  transportingMsgProtocol: String! # "acrossV3"
  transportingMessageId: String! # "{originChainId}-{depositId}"
  idMatching: String! # For Across, same as transportingMessageId since layers are fused
  
  # Asset information
  assetAddressOutbound: String # inputToken address
  assetAddressInbound: String # outputToken address  
  amountOutbound: BigInt # inputAmount
  amountInbound: BigInt # outputAmount
  
  # Addresses
  sender: String # depositor
  recipient: String # recipient
  targetAddress: String # For Across, this would be the SpokePool address on destination
  
  # Additional Across-specific data
  fillDeadline: BigInt
  exclusivityDeadline: BigInt
  exclusiveRelayer: String
  message: String
  
  # References
  crosschainMessage: CrosschainMessage!
}

